---
title: 背包九讲（一） 01背包
slug: knapsack-problem-01
tags: [背包九讲, 算法, 动态规划]
categories: 算法
mathjax: true
date: 2020-07-07T08:13:17+08:00
lastmod: 2020-07-07T08:13:17+08:00
---

学习来源：[B 站大雪莱-背包九讲专题 <i class="fa fa-external-link-alt"></i>](https://www.bilibili.com/video/BV1qt411Z7nE?from=search&seid=7823159650487960943)

> 背包问题(Knapsack problem)是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过 W 的前提下，总价值是否能达到 V？它是在 1978 年由 Merkle 和 Hellman 提出的。[<i class="fa fa-external-link-alt"></i>](https://baike.baidu.com/item/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/2416931?fr=aladdin "百度百科")

# 🎒 01 背包问题

<!--more-->

## ❓ 题目

> 有 $N$ 件物品和一个容量为 $V$ 的背包。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。
> 求解哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值

- **输入格式**

> 第一行两个整数，$N,V$，用空格隔开，分别表示物品数量和背包容积。
> 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值

- **输出格式**

> 输出一个整数，表示最大价值

- **数据范围**

> $0 < N,V \leq 1000$ > $0 < v_i,w_i \leq 1000$

## ✅ 解法一：二维动态规划

### 思路

&emsp;&emsp;二维数组 $dp$，考虑第一维是第 $i$ 件物品，第二维是装入背包的物品体积 $j$，每个元素 $dp[i][j]$ 就表示考虑前 $i$ 件物品并且装入体积等于 $j$ 的情况下的最大总价值。那么最终答案就在第 $N$ 维的所有体积中取最大即可。  
&emsp;&emsp;而对于每个元素来说，我们只需要考虑取第 $i$ 件物品或者不取即可，由于动态规划是从前往后遍历计算，所以决定取不取之后剩余的体积已经可以由之前的计算得来。

- 动规数组：$dp[N+1][V+1]$
- 初始化：全部初始化为 0
- 转移方程：$dp[i][j] = max(dp[i-1][j-v(i)]+w(i),\quad dp[i-1][j])$

### 代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int main() {
    int N, V;
    cin >> N >> V;
    // 定义数组并初始化
    int dp[N + 1][V + 1];
    memset(dp, 0, sizeof(dp));
    int v, w;
    // 状态转移计算
    for (int i = 1; i <= N; ++i) {
        cin >> v >> w;
        for (int j = 1; j <= V; ++j) {
            dp[i][j] = dp[i - 1][j];
            if (j >= v)
                dp[i][j] = max(dp[i-1][j-v]+w, dp[i][j]);
        }
    }
    // 遍历第 N 维寻找最大价值
    int ans = dp[N][0];
    for (int i = 1; i <= V; ++i) ans = max(ans, dp[N][i]);
    cout << ans << endl;
    return 0;
}
```

- 空间复杂度：$O(N*V)$
- 时间复杂度：$O(N*V)$

## ✅ 解法二：动态规划降维优化

### 思路

&emsp;&emsp;从解法一可以发现循环过程中第 $i$ 维的结果只与第 $i-1$ 维有关，我们很轻易可以想到优化的一般方法——使用滚动数组。但是，滚动数组仍然是二维数组，有没有办法使用一维数组得出答案呢？  
&emsp;&emsp;答案是有的。我们可以大胆去掉第一维，想象当前这个一维数组存储的就是二维数组计算中的第 $i-1$ 行，那么，我们要将其转化为第 $i$ 行的结果，只需要倒序遍历即可，因为通过转移方程可以发现 $j$ 体积的结果只取决于上一行小于等于 $j$ 的结果。  
&emsp;&emsp;可能一下想不通，直接上代码吧！

### 代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int main() {
    int N, V;
    cin >> N >> V;
    // 定义数组并初始化
    int dp[V + 1];
    memset(dp, 0, sizeof(dp));
    int v, w;
    // 状态转移计算
    for (int i = 1; i <= N; ++i) {
        cin >> v >> w;
        for (int j = V; j >= v; --j) {
            dp[j] = max(dp[j - v] + w, dp[j]);
        }
    }
    cout << dp[V] << endl;
    return 0;
}
```

- 空间复杂度：$O(V)$
- 时间复杂度：$O(N*V)$

&emsp;&emsp;可以发现，除了降维之外，还把最后的遍历找最大价值给去掉了，直接取 $dp[V]$ 就是答案。这里主要与初始化有关系，仔细思考初始化，发现我们把所有元素都初始化为了 0，这里其实就已经不代表体积恰好等于 $j$ 了，因为这样的话下一层即只考虑第一个物品时就极有可能从非 0 体积转移过去，也就造成了取了第一个物品的价值但体积却小于等于 $j$ 的情况。  
&emsp;&emsp;由此可以发现，我们的元素直接就代表了体积小于等于 $j$ 的最大价值，刚好满足题意，所以答案就是 $dp[V]$。

### 引申

&emsp;&emsp;那么，我们如何计算体积恰好等于 $V$ 时的最大价值呢？从上述分析的源头出发，既然是初始化导致体积不恰好等于，那么我们改变初始化方式使得所有状态只能从 0 体积转移即可。实际做法就是把除了 $dp[0]$ 以外的其余元素初始化为负无穷，这样的状态就必然是从 0 体积转移过去的，因为非 0 体积转移的结果是负无穷，在取 $max$ 时就会被取代。

## 🏆 总结

`01背包问题`的优化解法转移方程如下：

```c++
dp[j] = max(dp[j - v] + w, dp[j])
```
