---
title: 背包九讲（九） 背包问题求具体方案
slug: knapsack-problem-09
tags: [背包九讲, 算法, 动态规划]
categories: 算法
mathjax: true
date: 2020-08-03T15:05:36+08:00
lastmod: 2020-08-03T15:05:36+08:00
---

## ❓ 题目

> 有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。
> 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
> 输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。

<!--more-->

- **输入格式**

> 第一行两个整数，$N$，$V$，用空格隔开，分别表示物品数量和背包容积。
> 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。

- **输出格式**

> 输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。
> 物品编号范围是 $1…N$。

- **数据范围**

> $0 < N,V\leq 1000$ > $0 < v_i,w_i\leq 1000$

## ✅ 解决方案

### 思路

&emsp;&emsp;求具体方案也就是确定每件物品选还是不选，这个问题是没有办法在转移过程中确定答案的，因为每多考虑一个新的物品，之前物品选还是不选就有可能发生变化，只有当所有状态转移完毕后，通过倒推的方式去确定方案。

&emsp;&emsp;而题目要求输出字典序最小的方案，因此倒推时需要从第一件物品开始，所以状态转移时从最后一件物品开始倒着转移即可。

&emsp;&emsp;倒推的过程其实就是判断最终答案与当前物品的体积价值以及相应中间状态之间的关系。

### 代码

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

int main() {
    int N, V;
    cin >> N >> V;
    // 由于倒推需要用到中间状态，因此这里用二维数组保存所有状态
    int dp[N + 1][V + 1], v[N + 1], w[N + 1];
    memset(dp, 0, sizeof(dp));
    for (int i = N; i > 0; --i) cin >> v[i] >> w[i];
    for (int i = 1; i <= N; ++i) {
        for (int j = 1; j <= V; ++j) {
            dp[i][j] = dp[i - 1][j];
            if (j >= v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]);
        }
    }

    int cur = V;
    for (int i = N; i > 0; --i) {
        if (dp[i][cur] == dp[i - 1][cur - v[i]] + w[i]) {
            cout << N + 1 - i << " ";
            // 取完当前物品，目标体积需要减去当前体积
            cur -= v[i];
        }
    }

    return 0;
}
```

## 🔍 学习来源

[B 站大雪莱-背包九讲专题 <i class="fa fa-external-link-alt"></i>](https://www.bilibili.com/video/BV1Qt411R7v8?p=2&t=1608)
