[{"categories":"算法","contents":"\u0026emsp;\u0026emsp;A backtracking algorithm tries to construct a solution to a computational problem incrementally, one small piece at a time. Whenever the algorithm needs to decide between multiple alternatives to the next component of the solution, it recursively evaluates every alternative and then chooses the best one.——_Algorithms-JeffE_\n\r概述  实质上，回溯算法本身就属于一种递归算法。只不过相对于简单的递归来说，它的递归树一般分叉较多，更重要的是它的递归分支都是在决策中诞生的。之所以称之为回溯算法，就是因为我们一开始并不能确定哪一个决策是最优的，递归之后就需要回过头去试验其它决策即产生其它递归分支，最终采纳最适决策，返回其结果。\n 下面就书中的两个例子作总结，并归纳回溯算法的一般形式。\nN Queens  N 皇后问题是一个超级经典的回溯问题，其中的 N 代表棋盘的大小，下面是八皇后问题的相关描述。\n 在 8×8 格的国际象棋上摆放 8 个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有 76 种方案。1854 年在柏林的象棋杂志上不同的作者发表了 40 种不同的解，后来有人用图论的方法解出 92 种结果。如果经过 ±90 度、±180 度旋转，和对角线对称变换的摆法看成一类，共有 42 类。\n   💡 思路  这个问题的本质就是确定所有皇后的位置，而为了递归将其分为小问题计算，进而表述为确定每一行（或每一列）的皇后的位置，因此最终结果可以用一个数组来表示，数组中存储每一行中皇后的位置索引。\n 问题转化为确定数组中每个元素的值，确定的方式非常暴力，直接把每一个位置都尝试一遍即可，作出当前行决策后将剩余部分进行递归计算，直到每个位置都确定或者位置冲突而舍弃当前决策。\n 由于子问题计算时依赖于已经做好的决策因此需要将位置数组在递归中进行传递。\n📝 代码 伪代码\r\rC\u0026#43;\u0026#43; 实现\r\r\rPlaceQueens(Q[1.. n], r):\rif r = n + 1\rprint Q[1.. n]\relse\rfor j ← 1 to n\rlegal ← True\rfor i ← 1 to r − 1\rif (Q[i] = j) or (Q[i] = j + r − i) or (Q[i] = j − r + i)\rlegal ← False\rif legal\rQ[r] ← j\rPlaceQueens(Q[1.. n], r + 1) \u0026lt;\u0026lt;Recursion!\u0026gt;\u0026gt;\r\r\rvoid placeQueens(vector\u0026lt;int\u0026gt;\u0026amp; Q, int r) { if (r == Q.size()) printQueens(Q); else { for (int j = 0; j \u0026lt; Q.size(); ++j) { bool legal = true; for (int i = 0; i \u0026lt; r; ++i) { if (Q[i] == j || Q[i] == j + r - i || Q[i] == j - r + i) { legal = false; break; } } if (legal) { Q[r] = j; placeQueens(Q, r + 1); } } } } \r\r\r\r 根据程序计算，八皇后问题有 92 种解法。\nSubset Sum  子集合之和问题：给定一个正整数集合 X 和一个目标整数 T，问 X 中是否存在一个数字之和等于目标 T 的子集合？\n💡 思路  这个问题如果用回溯解决，那么其需要作的决策就是原始集合中的某个数字是否要纳入结果子集合中。我们如何在递归中体现出所作的决策呢？方法如下：\n 选取：将所选取的数字从集合中剔除，并将目标值减去所选数字 不选取：将所选取的数字从集合中剔除，目标值不变   可以看出，无论选不选当前数字，都会将其剔除，因为无论怎样你都做出了决策，当前数字就不能再考虑了。递归出口为目标值小于等于 0 或者集合为空。\n📝 代码 伪代码\r\rC\u0026#43;\u0026#43; 实现\r\r\r\u0026lt;\u0026lt;Does any subset of X sum to T ?\u0026gt;\u0026gt;\rSubsetSum(X, T):\rif T = 0\rreturn True\relse if T \u0026lt; 0 or X = ∅\rreturn False\relse\rx ← any element of X\rwith ← SubsetSum(X \\ {x}, T − x) \u0026lt;\u0026lt;Recurse!\u0026gt;\u0026gt;\rwout ← SubsetSum\r\r\rbool subsetSum(int nums[], int n, int T) { if (T == 0) return true; else if (T \u0026lt; 0 || n == 0) return false; else return subsetSum(nums, n - 1, T - nums[n - 1]) || subsetSum(nums, n - 1, T); } \r\r\r\r❓ 问题拓展 这个问题还延伸出很多变种，比如：\n 列出一个满足条件的子集合； 求出可能解的个数； 给数据加入权值，求满足条件的子集合的最大权值\u0026hellip;（这个问题实际上就是严格版的 01 背包问题，可以用动态规划求解）  其实所有问题都是一样的求解过程，只不过最后要的输出不同罢了，下面是针对上述第一个变种的伪码：\n伪代码\r\rC\u0026#43;\u0026#43; 实现\r\r\rConstructSubset(X, i, T):\rif T = 0\rreturn ∅\rif T \u0026lt; 0 or n = 0\rreturn None\rY ← ConstructSubset(X, i − 1, T)\rif Y != None\rreturn Y\rY ← ConstructSubset(X, i − 1, T − X[i])\rif Y != None\rreturn Y ∪ {X[i]}\rreturn None\r\r\rpair\u0026lt;vector\u0026lt;int\u0026gt;,bool\u0026gt; constructSubset(int nums[], int n, int T) { if (T == 0) return { {},true }; if (T \u0026lt; 0 || n == 0) return { {},false }; auto sub = constructSubset(nums, n - 1, T); if (sub.second) return sub; sub = constructSubset(nums, n - 1, T - nums[n - 1]); if (sub.second) { sub.first.push_back(nums[n - 1]); return sub; } return { {},false }; } \r\r\r\r 这个代码用另一个集合去存储结果，决策过程都一样，只不过当某些决策最终满足条件时，我们在回溯过程中将决策具象化到结果数组中。\n回溯算法一般模板  适用范围：求解过程是在作一系列形式相同的决策，并且之前的决策会影响之后决策的一类问题；  N Queens：决策每个皇后的位置，当前行决策受到之前行皇后位置的影响 Subset Sum：决策每个数字选不选，之前的决策会改变集合以及目标   算法考虑要点：  递归终止条件：达成目标或者舍弃决策 递归参数：体现之前决策或者其带来的影响；可以用于做出下一步决策\u0026hellip; 递归分支：分别进行分支决策，暴力考虑所有决策即可，分支较多时经常采用循环 决策恢复：回溯进行分支决策时要消除掉前一分支决策带来的影响，使决策状态回到上一步决策再进行下一步分支决策    参考文献 Algorithms-JeffE\n","permalink":"https://hotsnow-sean.github.io/posts/backtracking-algorithm/","tags":["算法","Backtracking","N Queens","SubsetSum"],"title":"回溯算法"},{"categories":null,"contents":"在线实用网址链接    序号 功能 链接     1 程序员工具箱（80+实用工具） https://tool.lu/   2 c/c++在线汇编查看 https://godbolt.org/   3 Github 代下载服务 http://g.widyun.com/   4 查找 dns 地址（用于修复 GitHub 访问） https://hostingchecker.com/   5 AcWing 代码练习 https://www.acwing.com/   6 音乐搜索下载 http://music.ifkdy.com/    实用程序    序号 名称 功能 官网 平台     1 Zeal 本地开发者文档 https://zealdocs.org/ Win/Linux/Mac   2 Rufus U 盘写录工具 http://rufus.ie/ Win/Linux    ","permalink":"https://hotsnow-sean.github.io/collection/","tags":null,"title":"珍宝阁"},{"categories":"算法","contents":"❓ 题目  有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 字典序最小的方案。这里的字典序是指：所选物品的编号所构成的序列。物品的编号范围是 $1…N$。\n  输入格式   第一行两个整数，$N$，$V$，用空格隔开，分别表示物品数量和背包容积。 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。\n  输出格式   输出一行，包含若干个用空格隔开的整数，表示最优解中所选物品的编号序列，且该编号序列的字典序最小。 物品编号范围是 $1…N$。\n  数据范围   $0 \u0026lt; N,V\\leq 1000$ \u0026gt; $0 \u0026lt; v_i,w_i\\leq 1000$\n ✅ 解决方案 思路  求具体方案也就是确定每件物品选还是不选，这个问题是没有办法在转移过程中确定答案的，因为每多考虑一个新的物品，之前物品选还是不选就有可能发生变化，只有当所有状态转移完毕后，通过倒推的方式去确定方案。\n 而题目要求输出字典序最小的方案，因此倒推时需要从第一件物品开始，所以状态转移时从最后一件物品开始倒着转移即可。\n 倒推的过程其实就是判断最终答案与当前物品的体积价值以及相应中间状态之间的关系。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // 由于倒推需要用到中间状态，因此这里用二维数组保存所有状态  int dp[N + 1][V + 1], v[N + 1], w[N + 1]; memset(dp, 0, sizeof(dp)); for (int i = N; i \u0026gt; 0; --i) cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; for (int i = 1; i \u0026lt;= N; ++i) { for (int j = 1; j \u0026lt;= V; ++j) { dp[i][j] = dp[i - 1][j]; if (j \u0026gt;= v[i]) dp[i][j] = max(dp[i][j], dp[i - 1][j - v[i]] + w[i]); } } int cur = V; for (int i = N; i \u0026gt; 0; --i) { if (dp[i][cur] == dp[i - 1][cur - v[i]] + w[i]) { cout \u0026lt;\u0026lt; N + 1 - i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 取完当前物品，目标体积需要减去当前体积  cur -= v[i]; } } return 0; } 🔍 学习来源 B 站大雪莱-背包九讲专题 \n","permalink":"https://hotsnow-sean.github.io/posts/knapsack-problem-09/","tags":["背包九讲","算法","动态规划"],"title":"背包九讲（九） 背包问题求具体方案"},{"categories":"算法","contents":"❓ 题目  有 $N$ 件物品和一个容量是 $V$ 的背包。每件物品只能使用一次。 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出 最优选法的方案数。注意答案可能很大，请输出答案模 $10^9+7$ 的结果。\n  输入格式   第一行有两个整数 $N$，$V$，用空格隔开，分别表示物品数量和背包容量。 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值。\n  输出格式   输出一个整数，表示 方案数 模 $10^9+7$ 的结果。\n  数据范围   $0 \u0026lt; N,V\\leq 1000$ \u0026gt; $0 \u0026lt; v_i,w_i\\leq 1000$\n ✅ 解决方案 思路  这道题就是 01 背包的变种，因此很简单。在 01 背包的状态转移过程中，我们每次的转移实际上就是在确定方案。而每次确定的方案无非就三种情况（选、不选、选不选一样）。对于前两种情况，当前的方案数与转移之前的方案数是一样的；而对于第三种情况，当前的方案数就是选与不选转移前方案的总和。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; #define MOD 1e9+7  int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // 这里的mv表示的是最大价值，也就是01背包问题中的dp  // 而这里的dp表示方案数  int mv[V + 1], dp[V + 1]; memset(mv, 0, sizeof(mv)); for (int i = 0; i \u0026lt;= V; ++i) dp[i] = 1; int v, w; for (int i = 0; i \u0026lt; N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; for (int j = V; j \u0026gt;= v; --j) { int no = mv[j]; int yes = mv[j - v] + w; int cnt = 0; // 通过两次if，可以完成三种情况的转移  if (no \u0026gt;= yes) { mv[j] = no; cnt += dp[j]; } if (yes \u0026gt;= no) { mv[j] = yes; cnt += dp[j - v]; } if (cnt \u0026gt; MOD) cnt -= MOD; dp[j] = cnt; } } cout \u0026lt;\u0026lt; dp[V] \u0026lt;\u0026lt; endl; return 0; } 🔍 学习来源 B 站大雪莱-背包九讲专题 \n","permalink":"https://hotsnow-sean.github.io/posts/knapsack-problem-08/","tags":["背包九讲","算法","动态规划"],"title":"背包九讲（八） 背包问题求方案数"},{"categories":"算法","contents":"❓ 题目  有 $N$ 种物品和一个容量为 $V$ 的背包。 物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。 如下图所示：\n graph TB\r1((1)) --- 2((2)) \u0026 3((3))\r2 --- 4((4)) \u0026 5((5))\r  如果选择物品 5，则必须选择物品 1 和 2。这是因为 2 是 5 的父节点，1 是 2 的父节点。 每件物品的编号是 $i$，体积是 $v_i$，价值是 $w_i$，依赖的父节点编号是 $p_i$。物品的下标范围是 $1…N$。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。\n  输入格式   第一行有两个整数 $N$，$V$，用空格隔开，分别表示物品个数和背包容量。 接下来有 $N$ 行数据，每行数据表示一个物品。 第 $i$ 行有三个整数 $v_i,w_i,p_i$，用空格隔开，分别表示物品的体积、价值和依赖的物品编号。 如果 $p_i = −1$，表示根节点。 数据保证所有物品构成一棵树。\n  输出格式   输出一个整数，表示最大价值\n  数据范围   $0 \u0026lt; N,V \\leq 100$ \u0026gt; $0 \u0026lt; v_i,w_i \\leq 100$ 父节点编号范围： 内部结点：$1\\leq p_i\\leq N$; 根节点 $p_i = −1$;\n ✅ 解决方案 思路  有依赖的背包问题中所有物品均以树上一个节点的形式存在，所以首先将树给建起来。这里采用邻接表的形式，方便遍历每个节点的子节点，而且以数组形式存储维护起来很轻松。\n建立数组 $n$，$e$。 其中 $n$ 用来存储每个节点自身的信息以及其第一个子节点在 $e$ 中的 $id$，长度为节点个数；$e$ 数组每个元素存储这条边所对应子节点在 $n$ 中的 $id$，以及下一个子节点在 $e$ 中的 $id$，长度为节点个数减一。通过这种方式只需要两个数组就可以将树信息表示出来。\n 接下来考虑如何进行动态规划。我们可以从树的根节点开始考虑，因为如果拿其它节点的物品，由于父子节点的约束关系，根节点必须被拿才能满足要求。而对于一个根节点，除非它本身的体积已经大于容积上限，否则我们必然从它的所有子树中求出一个最大价值，然后加上自己的价值就得到了最终答案。\n因此，对于每个节点的求解，又会转化到求其子节点的解，这明显就是递归的思路。最终代码如下。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;cstring\u0026gt;using namespace std; struct Node { int childID; int v, w; }; struct CNode { int next; int id; }; void dfs(Node n[], CNode e[], int *dp, int V, int root) { int son = n[root].childID; for (int j = V - 1; j \u0026gt;= n[root].v; --j) { dp[root * V + j] = n[root].w; } while (son != -1) { dfs(n, e, dp, V, e[son].id); for (int j = V - 1; j \u0026gt;= n[root].v; --j) { int limit = j - n[root].v; for (int k = 0; k \u0026lt;= limit; ++k) { dp[root * V + j] = max(dp[root * V + j], dp[e[son].id * V + k] + dp[root * V + j - k]); } } son = e[son].next; } } int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; Node n[N]; CNode e[N - 1]; int idx = 0; memset(n, -1, sizeof(n)); memset(e, -1, sizeof(e)); int root, tv, tw, tp; for (int i = 0; i \u0026lt; N; ++i) { cin \u0026gt;\u0026gt; tv \u0026gt;\u0026gt; tw \u0026gt;\u0026gt; tp; n[i].v = tv, n[i].w = tw; if (tp == -1) root = i; else e[idx].next = n[tp - 1].childID, e[idx].id = i, n[tp - 1].childID = idx++; } int dp[N][V + 1]; memset(dp, 0, sizeof(dp)); dfs(n, e, \u0026amp;dp[0][0], V + 1, root); cout \u0026lt;\u0026lt; dp[root][V] \u0026lt;\u0026lt; endl; return 0; } 🔍 学习来源 B 站大雪莱-背包九讲专题 \n","permalink":"https://hotsnow-sean.github.io/posts/knapsack-problem-07/","tags":["背包九讲","算法","动态规划"],"title":"背包九讲（七） 有依赖背包"},{"categories":"算法","contents":"🎒 分组背包问题 (B 站大雪莱-背包九讲专题 ) ❓ 题目  有 $N$ 种物品和一个容量为 $V$ 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。 每件物品的体积是 $v_{ij}$，价值是 $w_{ij}$，其中 $i$ 是组号，$j$ 是组内编号。 求解哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n  输入格式   第一行两个整数，$N,V$，用空格隔开，分别表示物品组数和背包容积。 接下来有 $N$ 组数据：\n 每组数据第一行有一个整数 $S_i$，表示第 $i$ 个物品组的物品数量； 每组数据接下来有 $S_i$ 行，每行有两个整数 $v_{ij},w_{ij}$，用空格隔开，分别表示第 $i$ 个物品组的第 $j$ 个物品的体积和价值；    输出格式   输出一个整数，表示最大价值\n  数据范围   $0 \u0026lt; N,V \\leq 100$ \u0026gt; $0 \u0026lt; v_i,w_i,s_i \\leq 100$\n ✅ 一般解法 思路  分组背包和多重背包的思路做法都很像，多重背包问题是在每次考虑时，去决定拿几个当前物品即‘0，1，2，\u0026hellip;’，直到当前物品的数量上限为止，也就是有 $s$ 种决策。而分组背包每组物品的决策是拿第几个，也就是还是有 $s$ 种决策。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // 定义数组并初始化  int dp[V + 1], last[V + 1]; memset(dp, 0, sizeof(dp)); int v, w, s; // 状态转移计算  for (int i = 0; i \u0026lt; N; ++i) { memcpy(last, dp, sizeof(dp)); cin \u0026gt;\u0026gt; s; while (s-- \u0026gt; 0) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; for (int j = V; j \u0026gt;= v; --j) { dp[j] = max(last[j - v] + w, dp[j]); } } } cout \u0026lt;\u0026lt; dp[V] \u0026lt;\u0026lt; endl; return 0; }  空间复杂度：$O(V)$ 时间复杂度：$O(N\\ast V\\ast s)$  引申  实际上多重背包是分组背包的一种特殊情况，就是当分组背包一组内的物品分别是一种物品进行 1、2、\u0026hellip;、s 个的打包时，此时和多重背包的效果就是一样的。也正因为多重背包是一种特殊情况，所以它才会有两种优化方法，而分组背包只能进行三重循环计算。\n","permalink":"https://hotsnow-sean.github.io/posts/knapsack-problem-06/","tags":["背包九讲","算法","动态规划"],"title":"背包九讲（六） 分组背包"},{"categories":"操作系统","contents":"玩 ArchLinux 双系统时遇到的一些小问题，记录一下\n要删除双系统时的操作（不用多余软件，方法来自网上）  首先将分给 Linux 的磁盘空间在 windows 的磁盘管理中进行格式化或删除卷，如果你不用这块空间的话不删除也无伤大雅； 接下来分两步，之间无顺序要求：  删除多余启动项（cmd 依次运行命令）  step1：管理员权限运行 Bcdedit /enum firmware，找到带有 Linux 字样的那一项，把它的标识符复制下来 step2：保存现有引导项 Bcdedit /export savebcd step3：删除多余引导项 Bcdedit /store savebcd /delete {2eda5080-380c-11ea-b5c6-806e6f6e6963} 大括号里的值换成第一步记录的标识符 step4：导入处理好的文件 Bcdedit /clean /import savebcd   删除多余引导项文件 启动项被删除之后只是启动时我们看不见选项了，但是实际上启动项文件依旧在磁盘里存放着，当然也要给它干掉咯。 + step1：打开 cmd 运行 diskpart + step2：在新窗口输入 list disk + step3：根据实际情况选择磁盘 select disk 0，把 0 换成启动分区所在的磁盘号 + step4：列出所选磁盘分区 list partition + step5：选中 EFI 所在分区 select partition 1，把 1 换成启动分区的编号，一般是那个 100M 或 512M 大的分区 + step5：给所选分区分配盘符 assign letter=p + step6：管理员权限打开记事本，按下打开文件选项，在此窗口中对相关文件进行删除操作 + step7：回到 diskpart 窗口，取消盘符分配 remove letter=p    Linux 和 Windows 时间不统一解决办法（二者选其一）  case1：在 Linux 终端输入 sudo hwclock --systohc --localtime case2：在 windows 下运行 \u0026lt; regedit \u0026gt; 打开注册表 依次进入 \\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation 新建名为 RealTimeIsUniversal 的 \u0026lt; QWORD \u0026gt; 值，令其为 1 [十六进制]  Linux 下键盘灯光控制 貌似只能用命令控制：\n linux 开启键盘灯光 xset led named 'Scroll Lock' linux 关闭键盘灯光 xset -led named 'Scroll Lock'  linux 获取窗口类信息 忘了有什么用了，反正运行后可以看到窗口的相关信息 xprop | awk ' /^WM_CLASS/{sub(/.* =/, \u0026quot;instance:\u0026quot;); sub(/,/, \u0026quot;\\nclass:\u0026quot;); print} /^WM_NAME/{sub(/.* =/, \u0026quot;title:\u0026quot;); print}'\ngrub2 命令行启动 Linux 系统 有时候启动系统莫名奇妙卡到 grub 的命令行，这时如果 linux 系统本身完好，可以用以下命令启动：\n ls 查看磁盘及分区信息，可以用来寻找 grub 所在分区 set root=(hdX,X) 选中找到的分区 linux /[linux内核文件] root=/dev/sdXX 内核文件就在所选分区内，文件名开头为 vmi，后面的 root 路径为根目录所在分区，不确定可以查看etc/fstab文件 initrd /[init文件] init 文件同样在所选分区，文件名开头为 init，后缀为 img boot  待续\u0026hellip;\u0026hellip;\n","permalink":"https://hotsnow-sean.github.io/posts/linux-win-issue/","tags":["Linux","ArchLinux","Helper"],"title":"Linux双系统问题杂谈（持续更新）"},{"categories":"算法","contents":"🎒 二维费用背包问题 (B 站大雪莱-背包九讲专题 ) ❓ 题目  有 $N$ 件物品和一个容量为 $V$ 的背包，背包能承受的最大重量是 $M$。 每件物品只能用一次。体积是 $v_i$，重量是 $m_i$，价值是 $w_i$。 求解哪些物品装入背包，可使这些物品的总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。 输出最大价值。\n  输入格式   第一行三个整数，$N,V,M$，用空格隔开，分别表示物品件数、背包容积和背包可承受最大重量。 接下来有 $N$ 行，每行三个整数 $v_i,m_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积、重量和价值。\n  输出格式   输出一个整数，表示最大价值\n  数据范围   $0 \u0026lt; N \\leq 1000$ \u0026gt; $0 \u0026lt; V,M \\leq 100$ \u0026gt; $0 \u0026lt; v_i,m_i \\leq 100$ \u0026gt; $-1 \u0026lt; w_i \\leq 1000$\n ✅ 解决方案 思路  这个其实还是 01 背包，只需要将一维费用扩展为二维费用即可。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int N, V, M; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V \u0026gt;\u0026gt; M; // 定义数组并初始化  int dp[V + 1][M + 1]; memset(dp, 0, sizeof(dp)); int v, m, w; // 状态转移计算  for (int i = 1; i \u0026lt;= N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; m \u0026gt;\u0026gt; w; for (int j = V; j \u0026gt;= v; --j) for (int k = M; k \u0026gt;= m; --k) dp[j][k] = max(dp[j - v][k - m] + w, dp[j][k]); } cout \u0026lt;\u0026lt; dp[V][M] \u0026lt;\u0026lt; endl; return 0; }  空间复杂度：$O(V*M)$ 时间复杂度：$O(N\\ast V\\ast M)$ ","permalink":"https://hotsnow-sean.github.io/posts/knapsack-problem-05/","tags":["背包九讲","算法","动态规划"],"title":"背包九讲（五） 二维费用背包"},{"categories":"算法","contents":"🎒 混合背包问题 (B 站大雪莱-背包九讲专题 ) ❓ 题目  有 $N$ 种物品和一个容量为 $V$ 的背包。 物品一共有三类：\n 第一类物品只能用 1 次（01 背包）； 第二类物品可以用无限多次（完全背包）； 第三类物品最多只能用 $s_i$ 次（多重背包）；  每种体积是 $v_i$，价值是 $w_i$。 求解哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n  输入格式   第一行两个整数，$N,V$，用空格隔开，分别表示物品种数和背包容积。 接下来有 $N$ 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 $i$ 件物品的体积、价值和数量。\n $s_i = -1$ 表示第 $i$ 种物品只能用 1 次； $s_i = 0$ 表示第 $i$ 种物品可以用无限次； $s_i \u0026gt; 0$ 表示第 $i$ 种物品可以用 $s_i$ 次；    输出格式   输出一个整数，表示最大价值\n  数据范围   $0 \u0026lt; N,V \\leq 100$ \u0026gt; $0 \u0026lt; v_i,w_i \\leq 1000$ \u0026gt; $-1 \u0026lt; s_i \\leq 1000$\n ✅ 解决方案 思路  在了解了之前三个问题的基础上，这个问题实际上并不难，只需要按照类别分别计算就行了，其中多重背包在这种数据范围下可以用一下二进制优化，这样一来，整个问题里就只存在 01 和完全两种问题了。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; struct Thing { int kind; int v, w; }; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; int dp[V + 1]; memset(dp, 0, sizeof(dp)); vector\u0026lt;Thing\u0026gt; things; int v, w, s; for (int i = 0; i \u0026lt; N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; if (s \u0026lt; 0) things.push_back({-1, v, w}); else if (s == 0) things.push_back({0, v, w}); else { for (int k = 1; k \u0026lt;= s; k \u0026lt;\u0026lt;= 1) { s -= k; things.push_back({-1, k * v, k * w}); } if (s \u0026gt; 0) things.push_back({-1, s * v, s * w}); } } for (auto thing : things) { if (thing.kind \u0026lt; 0) { for (int j = V; j \u0026gt;= thing.v; --j) dp[j] = max(dp[j], dp[j - thing.v] + thing.w); } else { for (int j = thing.v; j \u0026lt;= V; ++j) dp[j] = max(dp[j], dp[j - thing.v] + thing.w); } } cout \u0026lt;\u0026lt; dp[V] \u0026lt;\u0026lt; endl; return 0; } ","permalink":"https://hotsnow-sean.github.io/posts/knapsack-problem-04/","tags":["背包九讲","算法","动态规划"],"title":"背包九讲（四） 混合背包"},{"categories":null,"contents":"工科男士\r年方二四\r一事无成\r欢迎骚扰\r 916523964\r","permalink":"https://hotsnow-sean.github.io/about/","tags":null,"title":"关于我"},{"categories":"云的旅途","contents":"注意本文更新时间，部分内容可能已经不适用\r\rNext 主题版本问题  现在百度到的 next 官网写的比较旧，而且截至今日，这个主题已经在 GitHub 上开辟了新项目，原来的项目已经很久不更新了，新旧网址也比较像，这里推荐新网址：https://github.com/next-theme/hexo-theme-next ，根据其更新信息来获取最稳的 Next 主题以及配置方法。\n主题更新导致重新配置问题 🔧  这个问题的基本解决办法见hello word 这篇文章的分离主题配置部分，这里对其中提到的 Next 主题的 custom_file_path 配置项中的部分内容作如下说明:\n   子项目名称 文件路径（相对根目录，可改） 作用     postBodyEnd source/_data/post-body-end.njk 会被添加到文章结束尾部（用例）   bodyEnd source/_data/body-end.njk 整个页面的底部   variable source/_data/variables.styl 主题中 _variables 下的所有相关样式都可以在此覆盖修改   style source/_data/styles.styl 用于一般样式的修改添加（用例）     除了配置中这些，_data中还可以加入 next.yml 用于主题配置，这样主题配置就可以和主题文件本身分离了。需要用到哪个文件就创建并取消注释，用好这种方式基本可以实现大部分想要的功能。\n数学公式渲染问题 📕  经过尝试，当前版本（2020-7-10）可以不更换渲染器，只需把主题配置文件中的 mathjax 选项置为 true，并且在需要渲染公式的页面头部信息中写入 mathjax: true 即可，只要注意 markdown 文档的写法规范，一般都没什么问题。\n至于网上推荐的各种渲染器或多或少都有可能引发莫名其妙的问题，而且好几个渲染器已经基本弃坑，要注意甄别。目前 Next 针对数学渲染建议的渲染器是 hexo-renderer-pandoc，不过这个需要提前安装好 pandoc，而且我尝试的时候报错了，因此放弃。\nemoji 表情渲染问题 😀  首先当然可以选择常用的办法，更换可以使用 emoji 渲染插件的渲染器，例如：hexo-renderer-markdown-it，不过更换渲染器可能会引起文章其它部分的渲染问题，不推荐。 其次，经过尝试确认可以摒弃在 markdown 中打入表情代码的方式，而是直接打入表情本身，例如 win10 自带输入法中的表情，基本都可以渲染。\n重点，emoji 表情中有一系列蓝底白字数字的表情，这部分表情在部分浏览器尤其是手机端会呈现出一种乱码的状态，这个问题无法解决，或者说它可能本身就不算个问题，因为我们通过百度搜 emoji 表情大全，可以发现这些表情的 Native 版本本身就长成这个鬼样子。。。所以，尽量不要使用它们！\n手机端长文后面的内容看不见  这个问题经过测试，只会在手机端或者手机模拟器出现，文章内容仿佛突然被截断，但是你依旧可以选中文字进行复制等操作。这表明内容实际上是存在的，只是我们看不见，经过探索发现是动画导致的。\nNext 主题默认开启了页面各部分的动画，位于主题配置文件的如下内容：\nmotion:enable:trueasync:falsetransition:# All available transition variants: https://theme-next.js.org/animate/post_block:fadeInpost_header:fadeInDownpost_body:fadeInDowncoll_header:fadeInLeft# Only for Pisces | Gemini.sidebar:fadeInUp 既然只有长文会出现这个问题，再联系 animate动画库 官方的说明有这样一句话：Don't animate large elements，可以大胆猜测是由于元素过高或者元素高度加载不及时导致的动画执行不完全问题。 💡 解决方案一：改变或者去掉上面配置中 post_body 的动画，直接留空即可 💡 解决方案二：通过媒体查询，将手机端竖屏状态下的动画留空或改动。这种办法可以使得一般情况下动画效果依旧不变，只针对有问题的情况做出调整。如下：\n// 写到 'source/_data/styles.styl' 中即可\r@media only screen and (orientation: portrait) {\r.post-body {\ranimation: fadeIn !important;\r}\r}\r 之所以匹配竖屏是因为在测试中手机横屏不会出现这个问题，这里的查询条件可根据需要调整，要改变成的动画也随意调整到没问题即可，实在不行就置为 none 关闭动画。\n在文章末尾添加结束标识 🔚  网上有很多解答，但都大同小异而且太旧，用的方法里还都是 .swig 文件，而 Next 早就不用这种格式了。。这里可以采用之前提到的 custom_file_path 的方式进行添加，例如：\n{### 写到 'source/_data/post-body-end.njk' 中，并且取消相应主题配置中的注释 ###}\r{### 样式内容随便改，只要在这个if里就可以 ###}\r\u0026lt;div\u0026gt;\r{%- if not is_index -%}\r\u0026lt;div style=\u0026quot;text-align:center;color: #ccc;font-size:14px;\u0026quot;\u0026gt;-------------本文结束 \u0026lt;i class=\u0026quot;fa fa-paw\u0026quot;\u0026gt;\u0026lt;/i\u0026gt; 感谢您的阅读-------------\u0026lt;/div\u0026gt;\r{%- endif -%}\r\u0026lt;/div\u0026gt;\r效果见本文末尾，哈哈\nLogo 分离  由于已经采用了主题文件与其配置分离的方法，当然希望图片等资源也不要放在主题文件夹下，经过测试直接在项目根目录的 source 文件夹里创建 images 文件夹，然后把 logo 丢进去，这样配置路径本身就和默认一样即可，图片名改成自己的就好。\n流程图、序列图等渲染  Next 本身支持 markdown 图表展示，依赖于 mermaid，因此需要安装相关插件，推荐安装 hexo-filter-mermaid-diagrams，运行 npm i hexo-filter-mermaid-diagrams --save即可。安装完成之后在 Next 主题的配置文件中将 mermaid 开启就可以显示图表了。\n 问题： 这个问题会在同时启用了 pjax 时存在，由于 pjax 的 js 加载特性，导致页面只有在第一次加载或者刷新时图表才能正确显示。具体原理还未探究，但是目前版本（NexT version 8.0.0-rc.4）可用的解决办法如下：\n 打开 themes\\next\\layout\\_third-party\\tags\\mermaid.njk 文件，在 mermaid.initialize() 语句之后加一句 mermaid.contentLoaded() 便可以解决这个问题。  待续\u0026hellip;\u0026hellip;\n","permalink":"https://hotsnow-sean.github.io/posts/hexo-next-theme-issue/","tags":["博客","Hexo","next-theme","Helper"],"title":"Hexo-Next主题 可能遇到的问题解决方案（持续更新）"},{"categories":"算法","contents":"🎒 多重背包问题 (B 站大雪莱-背包九讲专题 ) ❓ 题目  有 $N$ 种物品和一个容量为 $V$ 的背包。 第 $i$ 种物品最多有 $s_i$ 件，每件体积是 $v_i$，价值是 $w_i$。 求解哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n  输入格式   第一行两个整数，$N,V$，用空格隔开，分别表示物品种数和背包容积。 接下来有 $N$ 行，每行三个整数 $v_i,w_i,s_i$，用空格隔开，分别表示第 $i$ 件物品的体积、价值和数量\n  输出格式   输出一个整数，表示最大价值\n  数据范围   $0 \u0026lt; N,V \\leq 100$ \u0026gt; $0 \u0026lt; v_i,w_i,s_i \\leq 100$\n ✅ 一般解法 思路  根据上一讲内容的一般解法，我们很容易想到，多重背包可以在每次考虑时，去决定拿几个当前物品即‘0，1，2，\u0026hellip;’，直到当前物品的数量上限（类比完全背包的直到体积上限，这里多了一个数量的限制）为止。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // 定义数组并初始化  int dp[V + 1]; memset(dp, 0, sizeof(dp)); int v, w, s; // 状态转移计算  for (int i = 1; i \u0026lt;= N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; for (int j = V; j \u0026gt;= v; --j) { // 从 1 个开始枚举直到数量上限或者拿不下  for (int k = 1; k \u0026lt;= s \u0026amp;\u0026amp; k * v \u0026lt;= j; ++k) dp[j] = max(dp[j - k * v] + k * w, dp[j]); } } cout \u0026lt;\u0026lt; dp[V] \u0026lt;\u0026lt; endl; return 0; }  空间复杂度：$O(V)$ 时间复杂度：$O(N\\ast V\\ast s)$ 在数据都在 100 范围内情况下，大概是一百万量级  ✅ 二进制优化解法  提升后的数据范围   $0 \u0026lt; N \\leq 1000$ \u0026gt; $0 \u0026lt; V \\leq 2000$ \u0026gt; $0 \u0026lt; v_i,w_i,s_i \\leq 2000$\n 思路  这里将数据范围增大，此时如果继续用一般解法，时间复杂度将上升到十亿量级以上，显然是不可取的。初步优化的思路是将多重背包问题化为 01 背包问题进而减少内层循环，首先可以想到的就是我们重新构造物品池，将每种物品都按一个一个拆开放进物品池里，此种物品有几个就放几个进去，这样的话，对放进去的每个物品而言，就又变成只有取和不取两种选择了，也即化为了 01 背包。\n但是继续分析其复杂度发现，拆开之后代码的第一重循环量级变成了 $N*s$，也就是说，虽然少了一重循环但总的时间复杂度并没有下降。\n 那么现在的目标就是实现化为 01 背包的基础上，减少第一重循环的次数。也就是说，不能采用有几个就分成几份这样的笨办法了！当当当~~，二进制拆分横空出世\n我们拆分一种物品的规则就是，当我们任意从拆分出来的物品中选取或不选取的时候，能够凑成所有小于等于此种物品总数量的数量。而二进制拆分也可以做到这一点，并且它拆分出来的份数更少，能够达到减小时间复杂度的目的。\n 二进制拆分：  其实就是把一个数按照 1,2,4,8,16...... 这样的只有一个1位的二进制数进行拆分。 例如：19 可以拆成 1、2、4、8、4（最后一个 4 是为了使全取的时候不超过原值）     使用这种拆法，每种物品会被拆为 $log(s)$ 份，总的时间复杂度也将降到 $10^7$ 量级。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; struct Good { int v, w; }; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // 定义数组并初始化  int dp[V + 1]; memset(dp, 0, sizeof(dp)); // 新的物品池  vector\u0026lt;Good\u0026gt; goods; int v, w, s; // 物品池重新构造  for (int i = 1; i \u0026lt;= N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; for (int j = 1; j \u0026lt;= s; j \u0026lt;\u0026lt;= 1) { s -= j; goods.push_back({v * j, w * j}); } if (s \u0026gt; 0) goods.push_back({v * s, w * s}); } // 化为01背包的状态转移  for (auto good : goods) for (int j = V; j \u0026gt;= good.v; --j) dp[j] = max(dp[j], dp[j - good.v] + good.w); cout \u0026lt;\u0026lt; dp[V] \u0026lt;\u0026lt; endl; return 0; }  空间复杂度：$O(V + N * \\log(s))$ 时间复杂度：$O(N\\ast V\\ast \\log(s))$ 按此时题目的数据范围，大概是千万量级  ✅ 单调队列优化解法  提升后的数据范围   $0 \u0026lt; N \\leq 1000$ \u0026gt; $0 \u0026lt; V \\leq 20000$ \u0026gt; $0 \u0026lt; v_i,w_i,s_i \\leq 20000$\n 思路  数据范围再次增大后，如果用二进制优化解法，时间复杂度又将上升到$3 \\times 10^8$，所以不得不继续寻求新的优化方法。 这部分较难，希望以后还能看懂 233\n 首先回到最初的起点，观察一下最一般解法的状态转移部分：\nfor (int i = 1; i \u0026lt;= N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; for (int j = V; j \u0026gt;= v; --j) for (int k = 1; k \u0026lt;= s \u0026amp;\u0026amp; k * v \u0026lt;= j; ++k) dp[j] = max(dp[j - k * v] + k * w, dp[j]); }  可以发现内部的两层循环做的事情就是，在来了一个新物品后，将整个 dp 数组进行更新。继续观察 dp 数组每个元素的更新过程：\ndp[j] = max(dp[j - k * v] + k * w, dp[j]);  又可以发现一件事，对于 dp[j] 来说，它的状态只可能从 dp[j - k * v] 转移而来，而 j 与 j - k * v 的关系就是——与 v 同余，每一轮来了一个新物品去更新 dp 数组的时候，实际上整个数组可以被分为若干类，分组的依据就是索引与v同余，总共分为v组。同一组之间才会发生状态转移，不同组之间毫无影响。\n紧接着分析同一组内部的转移，以余数为 1 举例，我们需要更新的有以下这些：\n// dp[1], dp[1 + v], dp[1 + 2 * v], ... dp[1 + k * v] 其中 1 + k * v 小于等于 V  观察转移方程，对于 dp[1 + n * v]，n代表0到k的任一值 的更新，将其代入转移方程得到(用 last 代表这个物品考虑之前的 dp 数组值)：\ndp[1 + n * v] = max(last[1 + n * v - k * v] + k * w); // 式子中的 k 属于 [0, min(s, (1 + n * v) / v)] 即 [0, min(s,n)] // 将 n - k 记作 m，则 m 属于 [max(0,n-s), n]，进而式子化为： dp[1 + n * v] = max(last[1 + m * v] + (n - m) * w); // 我们将余数化为一般，整个 1 + n * v 用 j 来表示，式子化为： dp[j] = max(last[i] + (j - i) / v * w); // 其中的 i 就是与 j 同组且小于等于 j 的索引序列，序列为等差，公差为 v // 到这里其实就已经化为经典的单调队列问题了：找出一组数里固定长度范围内的最大值，这里的范围就是 s  单调队列的具体做法不在这里展开，直接上优化后的代码：\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; int dp[V + 1], last[V + 1], q[V + 1]; memset(dp, 0, sizeof(dp)); int v, w, s; for (int i = 0; i \u0026lt; N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; s; memcpy(last, dp, sizeof(dp)); // 枚举余数，也就是分组遍历  for (int j = 0; j \u0026lt; v; ++j) { int head = -1, tail = 0; // 真正的单调队列代码  for (int k = j; k \u0026lt;= V; k += v) { dp[k] = last[k]; if (head \u0026gt;= tail \u0026amp;\u0026amp; k - q[tail] \u0026gt; s * v) ++tail; if (head \u0026gt;= tail) dp[k] = max(last[q[tail]] + (k - q[tail]) / v * w, dp[k]); while(head \u0026gt;= tail \u0026amp;\u0026amp; last[q[head]] - (q[head] - j) / v * w \u0026lt;= last[k] - (k - j) / v * w) --head; q[++head] = k; } } } cout \u0026lt;\u0026lt; dp[V] \u0026lt;\u0026lt; endl; return 0; }  虽然可能多用了两个数组辅助空间，但这种方法在如此高的数据范围下时间复杂度也仅仅是 $10^6$ 级别，真不愧是究极的背包解法，理解上的难度也是杠杠的！\n🏆 总结 多重背包问题的解法对应于不同的数据范围有不同的思考方式，其中二进制优化方式应对不是非常大的数据范围已经足够了。而单调队列优化着实很难一下想通啊。。。\n","permalink":"https://hotsnow-sean.github.io/posts/knapsack-problem-03/","tags":["背包九讲","算法","动态规划"],"title":"背包九讲（三） 多重背包"},{"categories":"算法","contents":"🎒 完全背包问题 (B 站大雪莱-背包九讲专题 ) ❓ 题目  有 $N$ 件物品和一个容量为 $V$ 的背包，每种物品都有无限件可用。 第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。 求解哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。\n  输入格式   第一行两个整数，$N,V$，用空格隔开，分别表示物品数量和背包容积。 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值\n  输出格式   输出一个整数，表示最大价值\n  数据范围   $0 \u0026lt; N,V \\leq 1000$ \u0026gt; $0 \u0026lt; v_i,w_i \\leq 1000$\n ✅ 初步解法 思路  从上一讲内容的结论出发得到下面这个转移方程\ndp[j] = max(dp[j - v] + w, dp[j]) 这个方程实际上代表了我们每次考虑一个新的物品时，只要去决定拿与不拿即可，也就是 01 背包问题名字里面的‘01’的含义。那么我们很容易想到，完全背包可以在每次考虑时，去决定拿几个当前物品即‘0，1，2，\u0026hellip;’，直到拿不下为止。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // 定义数组并初始化  int dp[V + 1]; memset(dp, 0, sizeof(dp)); int v, w; // 状态转移计算  for (int i = 1; i \u0026lt;= N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; for (int j = V; j \u0026gt;= v; --j) { // 从 1 个开始枚举直到拿不下  for (int k = 1; k * v \u0026lt;= j; ++k) dp[j] = max(dp[j - k * v] + k * w, dp[j]); } } cout \u0026lt;\u0026lt; dp[V] \u0026lt;\u0026lt; endl; return 0; }  空间复杂度：$O(V)$ 时间复杂度：$O(N*V^2)$  ✅ 优化解法 思路  优化解法实际上代码相当简单，就是将 01 背包中的倒序遍历改为正序遍历即可。那么为什么这样就可以代表完全背包呢？在 01 背包的分析中我们知道之所以需要倒序遍历，是因为每次状态计算都会从上一层即不考虑当前物品的情况下转移，如果正序遍历，会导致我们用于更新的状态是已经考虑当前物品的情况下的价值，也就是随着体积的增长，当前物品会被多次考虑直到预定体积为止。啪唧~~，巧了，完全背包问题要的就是当前物品可以被无限次使用直到放不下，因此正序遍历即可完成。\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // 定义数组并初始化  int dp[V + 1]; memset(dp, 0, sizeof(dp)); int v, w; // 状态转移计算  for (int i = 1; i \u0026lt;= N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; // 注意体积从 v 开始增长，因为如果小于 v 则拿不下当前物品也就没必要更新状态  for (int j = v; j \u0026lt;= V; ++j) { dp[j] = max(dp[j - v] + w, dp[j]); } } cout \u0026lt;\u0026lt; dp[V] \u0026lt;\u0026lt; endl; return 0; }  空间复杂度：$O(V)$ 时间复杂度：$O(N*V)$  🏆 总结 完全背包问题的优化解法转移方程与01背包完全相同，区别只在于遍历的顺序不同。\n","permalink":"https://hotsnow-sean.github.io/posts/knapsack-problem-02/","tags":["背包九讲","算法","动态规划"],"title":"背包九讲（二） 完全背包"},{"categories":"算法","contents":"学习来源：B 站大雪莱-背包九讲专题 \n 背包问题(Knapsack problem)是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过 W 的前提下，总价值是否能达到 V？它是在 1978 年由 Merkle 和 Hellman 提出的。\n 🎒 01 背包问题 ❓ 题目  有 $N$ 件物品和一个容量为 $V$ 的背包。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。 求解哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值\n  输入格式   第一行两个整数，$N,V$，用空格隔开，分别表示物品数量和背包容积。 接下来有 $N$ 行，每行两个整数 $v_i,w_i$，用空格隔开，分别表示第 $i$ 件物品的体积和价值\n  输出格式   输出一个整数，表示最大价值\n  数据范围   $0 \u0026lt; N,V \\leq 1000$ \u0026gt; $0 \u0026lt; v_i,w_i \\leq 1000$\n ✅ 解法一：二维动态规划 思路  二维数组 $dp$，考虑第一维是第 $i$ 件物品，第二维是装入背包的物品体积 $j$，每个元素 $dp[i][j]$ 就表示考虑前 $i$ 件物品并且装入体积等于 $j$ 的情况下的最大总价值。那么最终答案就在第 $N$ 维的所有体积中取最大即可。\n而对于每个元素来说，我们只需要考虑取第 $i$ 件物品或者不取即可，由于动态规划是从前往后遍历计算，所以决定取不取之后剩余的体积已经可以由之前的计算得来。\n 动规数组：$dp[N+1][V+1]$ 初始化：全部初始化为 0 转移方程：$dp[i][j] = max(dp[i-1][j-v(i)]+w(i),\\quad dp[i-1][j])$  代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // 定义数组并初始化  int dp[N + 1][V + 1]; memset(dp, 0, sizeof(dp)); int v, w; // 状态转移计算  for (int i = 1; i \u0026lt;= N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; for (int j = 1; j \u0026lt;= V; ++j) { dp[i][j] = dp[i - 1][j]; if (j \u0026gt;= v) dp[i][j] = max(dp[i-1][j-v]+w, dp[i][j]); } } // 遍历第 N 维寻找最大价值  int ans = dp[N][0]; for (int i = 1; i \u0026lt;= V; ++i) ans = max(ans, dp[N][i]); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; }  空间复杂度：$O(N*V)$ 时间复杂度：$O(N*V)$  ✅ 解法二：动态规划降维优化 思路  从解法一可以发现循环过程中第 $i$ 维的结果只与第 $i-1$ 维有关，我们很轻易可以想到优化的一般方法——使用滚动数组。但是，滚动数组仍然是二维数组，有没有办法使用一维数组得出答案呢？\n答案是有的。我们可以大胆去掉第一维，想象当前这个一维数组存储的就是二维数组计算中的第 $i-1$ 行，那么，我们要将其转化为第 $i$ 行的结果，只需要倒序遍历即可，因为通过转移方程可以发现 $j$ 体积的结果只取决于上一行小于等于 $j$ 的结果。\n可能一下想不通，直接上代码吧！\n代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std; int main() { int N, V; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; V; // 定义数组并初始化  int dp[V + 1]; memset(dp, 0, sizeof(dp)); int v, w; // 状态转移计算  for (int i = 1; i \u0026lt;= N; ++i) { cin \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; for (int j = V; j \u0026gt;= v; --j) { dp[j] = max(dp[j - v] + w, dp[j]); } } cout \u0026lt;\u0026lt; dp[V] \u0026lt;\u0026lt; endl; return 0; }  空间复杂度：$O(V)$ 时间复杂度：$O(N*V)$   可以发现，除了降维之外，还把最后的遍历找最大价值给去掉了，直接取 $dp[V]$ 就是答案。这里主要与初始化有关系，仔细思考初始化，发现我们把所有元素都初始化为了 0，这里其实就已经不代表体积恰好等于 $j$ 了，因为这样的话下一层即只考虑第一个物品时就极有可能从非 0 体积转移过去，也就造成了取了第一个物品的价值但体积却小于等于 $j$ 的情况。\n由此可以发现，我们的元素直接就代表了体积小于等于 $j$ 的最大价值，刚好满足题意，所以答案就是 $dp[V]$。\n引申  那么，我们如何计算体积恰好等于 $V$ 时的最大价值呢？从上述分析的源头出发，既然是初始化导致体积不恰好等于，那么我们改变初始化方式使得所有状态只能从 0 体积转移即可。实际做法就是把除了 $dp[0]$ 以外的其余元素初始化为负无穷，这样的状态就必然是从 0 体积转移过去的，因为非 0 体积转移的结果是负无穷，在取 $max$ 时就会被取代。\n🏆 总结 01背包问题的优化解法转移方程如下：\ndp[j] = max(dp[j - v] + w, dp[j]) ","permalink":"https://hotsnow-sean.github.io/posts/knapsack-problem-01/","tags":["背包九讲","算法","动态规划"],"title":"背包九讲（一） 01背包"},{"categories":"操作系统","contents":"2020-08-19 更新添加问题解决章节\n2020-07-30 更新最新联网方式以及修正部分内容\n 之前玩 Linux 时记录的文档，托管到博客上做记录\n基本根据ArchLinux 官方向导 而来，综合了一些会遇到的问题\n注意本文更新时间，部分内容可能已经不适用\r\rArchLinux Install Guide 一、 准备事项 1、连接网络（根据情况选择以下三种方法之一）  准备工作：使用 ip link 命令查看网卡状态，若网卡未开启，使用命令 ip link set up interface 开启  1.1 使用 wifi-menu 连接无线  这种方法看不到隐藏网络  1.2 连接有线网络  有线网络只需准备好后，只需要分配 IP，使用命令 dhcpcd \u0026amp;  1.3 使用 wpa_supplicant 连接无线  a. 生成网络配置文件：wpa_passphrase MYSSID PASSWORD \u0026gt; internet.conf b. 若为隐藏网络，编辑生成的配置文件，加入一行 scan_ssid=1 c. 调用配置文件连接网络：wpa_supplicant -B -i interface -c internet.conf \u0026amp; d. 分配 IP：dhcpcd \u0026amp;  1、连接网络（2020 年 7 月份之后的安装镜像采用的新方法）  查看网卡信息等依旧可以采用上边提到的 ip link 等方法。 具体网络连接只需要采用一个工具：iwctl ，简单易用，轻松应对有线无线隐藏等各种情况。  2、同步时间  timedatectl set-ntp true  二、 分区并挂载  使用 fdisk -l 查看目前分区情况，并记下需要分区的磁盘号 命令 cfdisk /dev/sda 其中/dev/sda 为需要分区的磁盘 分区：按照喜好大小分配即可，此次分区为 根目录 48G，家目录 68G，交换分区 4G 格式化  mkfs.fat -F32 /dev/sdaX 已经有 EFI 分区则不要这条命令 mkfs.ext4 /dev/sda1 建立根目录及家目录格式 mkswap /dev/sda2 建立交换分区及开启交换分区 swapon /dev/sda2   挂载  mount /dev/sda1 /mnt mount /dev/sda3 /mnt/home mount /dev/sdaX /mnt/boot    三、 修改软件源  vim /etc/pacman.d/mirrolist 将其中想要使用的源提到最前面，这步在第四步之前均可  四、 安装基础包  pacstrap /mnt base linux linux-firmware（最好查看官方 wiki，防止更新变化） pacstrap /mnt base-devel 可选 配置 fstab 文件 genfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab  五、 进入/mnt 并配置   arch-chroot /mnt\n  更改时区\n ln -sf /usr/share/zoneinfo/Region/City /etc/localtime hwclock --systohc    语言配置编辑\n vim /etc/locale.gen 去掉要使用语言前的注释 vim /etc/locale.conf 输入 LANG=en_US.UTF-8 运行 locale-gen    安装网络包\n pacman -S wpa_supplicant dhcpcd  【修正】只需安装 networkmanager ，然后运行 systemctl enable NetworkManager.service 让其开机自启即可。无需安装之前的两个包，防止冲突    网络配置\n 在 /etc/hostname 文件中输入 myhostname vim /etc/hosts 输入以下内容 127.0.0.1\tlocalhost\r::1\tlocalhost\r127.0.1.1\tmyhostname.localdomain\tmyhostname\r    passwd 设置 root 用户密码\n  安装引导程序\n pacman -S grub efibootmgr os-prober intel-ucode grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB grub-mkconfig -o /boot/grub/grub.cfg    六、 退出并重启  exit 退出 /mnt umount -R /mnt  七、 桌面环境安装 1、创建普通用户  创建并添加用户到组：useradd -m -G wheel -s login_shell username 设置密码：passwd username 开启 sudo 命令权限：visudo 取消 wheel 行注释  2、开启 multilib 软件库  vim /etc/pacman.conf 取消对应注释  3、安装图形服务  pacman -S xorg  4、安装显卡驱动（根据硬件查找官网）  intel：xf86-video-intel lib32-virtualgl OpenGL：mesa nvidia-390xx-utils nvidia：nvidia-390xx lib32-nvidia-390xx-utils 新显卡直接使用 nvidia 即可 bumblebee 存在性能问题，弃用 添加用户到组：gpasswd -a user bumblebee 开启服务：bumblebeed.service 此时双显卡选择采用 官方提到的其它解决方案  中的一个合适的即可  5、安装 KDE  pacman -S plasma kde-applications 检查 sddm, sddm-kcm 开启服务 systemctl enable sddm  6、杂项安装  中文字体：pacman -S ttf-dejavu wqy-microhei 网络  pacman -S networkmanager plasma-nm systemctl enable NetworkManager    八、使用中可能的问题 1、ArchlinuxCN 仓库使用问题 在使用 ArchlinuxCN 中文社区仓库时，除了添加相应的服务器地址，还需要安装 archlinuxcn-keyring 包来导入 GPG key，安装时，可能会遇到很多 ERROR 报错。这时可以参考 密钥环这篇文， 以 root 权限用以下命令解决：\npacman -Syu haveged\rsystemctl start haveged\rsystemctl enable haveged\rrm -fr /etc/pacman.d/gnupg\rpacman-key --init\rpacman-key --populate archlinux\rpacman-key --populate archlinuxcn\r运行完这些命令后再去尝试安装 archlinuxcn-keyring 包，应该就不会报错了。\n","permalink":"https://hotsnow-sean.github.io/posts/arch-install-guide/","tags":["Linux","ArchLinux","Helper"],"title":"Arch安装向导"},{"categories":"云的旅途","contents":"第一篇博文，没什么内容，依旧充满情怀地对这个世界问声好，Hello world!\n其实是由于 hexo 搭建博客必须保证至少有一篇博文才能正常使用，233，顺便简单记录一下搭建博客的过程\n使用 Hexo 搭建个人博客流程记录 准备工作 必要安装的软件程序：nodejs、git 需要的账号：github 账户\n搭建流程  在 github 上创建一个仓库，仓库名为 GitHub用户名.github.io，搭建完成后将用这个链接访问博客 运行 npm install -g hexo-cli 安装 hexo 在本地新建文件夹用于存储相关内容，然后进入此文件夹，命令行下运行 hexo init，等待运行完毕，脚手架工具将在此文件夹下创建好所需的所有文件 到这一步，其实已经可以在本地查看博客页面了，运行 hexo serve 或 hexo s，即可打开本地服务器，打开浏览器访问 localhost:4000，啪唧，博客出现了 当然，我们还需要将其部署到远端 GitHub 上，也就是第一步创建的仓库。打开本地博客文件夹下的 _config.yml 文件，翻到文件底部deploy配置项，将type设为git，将repo设为仓库的 GitHub 链接地址，将branch设为master。 配置好后，运行 hexo d 即可部署博客到仓库了（过程中可能需要登录 git 账户） OK，万事俱备，已经可以通过第一步中的链接正常访问博客喽！！！接下来就让无处安放的才华在这里生根发芽吧，冲冲冲 👊👊👊  后续更新 为了备份 hexo 源码到仓库，实现多终端无缝衔接撰写博客，作以下步骤：\n 在博客部署所在的仓库新建分支 hexo，并设为默认 在本地将仓库克隆下来 将克隆到的文件夹里除 .git 文件夹之外全部删除 将原博客文件夹里除 .deploy_git 和 public 之外的所有文件文件夹移动到新克隆下的文件夹里 到此，就可以使用 git push 等相关操作将源码文件上传到 hexo 分支了，当更换设备后可以直接克隆下来运行 npm install 后继续编写 注意点：   将主题文件夹里面的 .git 删除，因为仓库无法嵌套上传 使用 .gitignore 文件，将 node_modules 文件夹以及第 4 步提到的文件夹排除在上传之外  最新更新 - 重构源文件结构 + 分离主题配置 由于主题文件经常会有更新，如果直接在主题内部配置，当你更新主题时你的配置项将全部消失需要重新配置。因此采用 Next 主题 推荐的方式进行配置，完全不改动主题文件夹，这样就可以使用 git pull 来直接拉取最新主题并且保留原本的配置了。具体做法如下：\n 选择一种配置方式，Next 主题提供两种方式：   一是直接在 Hexo 项目的配置文件 _config.yml 中加入 theme_config 选项，有关主题的配置都写在这个配置项下面； 二是在项目的 source/_data 文件夹下（没有就创建），创建 next.yml 文件，主题配置可直接写入这个文件 ✨ 这里我选择第二种方式，因为第一种方式在修改后必须重启 hexo serve 才能看到效果（如果正在serve），并且和项目配置混在一个文件，还需要多缩进一格，感觉不是很爽就对了。【注：经实测，第二种方式的修改也不会像直接修改主题内部配置那样立刻应用到页面上，但是也不需要重启 serve，多保存几次或者等一会儿都可以】  将需要改变的主题配置项复制到 next.yml 文件，修改保存即可 除配置项外，样式文件也可以分离修改，在主题配置文件中有 custom_file_path 这样一项配置，将其中的 variable、style 选项打开，并按照其路径名称在 source/_data 文件夹下建立相应文件，之后，主题中 source/css/_variables 文件夹里所有需要修改的样式都可以放入对应新建立的文件里，而其它需要修改的样式则可以放入新建立的另一个文件里。   默认 Hexo 文档哦 👇\nWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start Create a new post $ hexo new \u0026#34;My New Post\u0026#34; More info: Writing\nRun server $ hexo server More info: Server\nGenerate static files $ hexo generate More info: Generating\nDeploy to remote sites $ hexo deploy More info: Deployment\n","permalink":"https://hotsnow-sean.github.io/posts/hello-world/","tags":["博客","Hexo"],"title":"Hello World - Hexo and Next Guild"}]